# æœåŠ¡ç«¯å†²çªå¤„ç†æ–¹æ¡ˆ

## ğŸ¯ è®¾è®¡åŸåˆ™

### æ ¸å¿ƒç†å¿µ
- **æœåŠ¡ç«¯ä¸ºçœŸç†çš„å”¯ä¸€æ¥æº**ï¼šæ‰€æœ‰å†²çªç”±æœåŠ¡ç«¯ç»Ÿä¸€å¤„ç†
- **å®¢æˆ·ç«¯ç®€åŒ–é€»è¾‘**ï¼šå®¢æˆ·ç«¯åªè´Ÿè´£ä¸Šä¼ å’Œåº”ç”¨ç»“æœ
- **æ•°æ®ä¸€è‡´æ€§ä¿è¯**ï¼šç¡®ä¿æ‰€æœ‰è®¾å¤‡æœ€ç»ˆæ•°æ®ä¸€è‡´
- **é€æ˜åŒ–å¤„ç†**ï¼šå†²çªå¤„ç†å¯¹ç”¨æˆ·å°½å¯èƒ½é€æ˜

## ğŸ—ï¸ æœåŠ¡ç«¯å†²çªå¤„ç†æ¶æ„

### 1. å†²çªæ£€æµ‹æµç¨‹
```mermaid
graph TB
    A[å®¢æˆ·ç«¯ä¸Šä¼ æ•°æ®] --> B[æœåŠ¡ç«¯æ¥æ”¶è¯·æ±‚]
    B --> C{æ•°æ®æ˜¯å¦å­˜åœ¨?}
    C -->|ä¸å­˜åœ¨| D[ç›´æ¥ä¿å­˜]
    C -->|å­˜åœ¨| E[æ£€æµ‹å†²çªç±»å‹]
    E --> F{å†²çªç±»å‹åˆ¤æ–­}
    F -->|ç‰ˆæœ¬å†²çª| G[æ—¶é—´æˆ³æ¯”è¾ƒ]
    F -->|å¹¶å‘å†²çª| H[æ™ºèƒ½åˆå¹¶]
    F -->|æ•°æ®æŸå| I[æ•°æ®ä¿®å¤]
    G --> J[åº”ç”¨è§£å†³ç­–ç•¥]
    H --> J
    I --> J
    J --> K[ä¿å­˜è§£å†³ç»“æœ]
    K --> L[è¿”å›å¤„ç†ç»“æœ]
    D --> M[è¿”å›æˆåŠŸ]
```

### 2. å†²çªç±»å‹å®šä¹‰
```javascript
const CONFLICT_TYPES = {
    // ç‰ˆæœ¬å†²çªï¼šå®¢æˆ·ç«¯ç‰ˆæœ¬ä¸æœåŠ¡ç«¯ç‰ˆæœ¬ä¸åŒ¹é…
    VERSION_CONFLICT: {
        code: 'VERSION_CONFLICT',
        description: 'æ•°æ®ç‰ˆæœ¬ä¸åŒ¹é…',
        resolution_strategy: 'timestamp_comparison'
    },
    
    // å¹¶å‘å†²çªï¼šå¤šè®¾å¤‡åŒæ—¶ä¿®æ”¹ç›¸åŒæ•°æ®
    CONCURRENT_CONFLICT: {
        code: 'CONCURRENT_CONFLICT', 
        description: 'å¹¶å‘ä¿®æ”¹å†²çª',
        resolution_strategy: 'intelligent_merge'
    },
    
    // å®Œæ•´æ€§å†²çªï¼šæ•°æ®å“ˆå¸ŒéªŒè¯å¤±è´¥
    INTEGRITY_CONFLICT: {
        code: 'INTEGRITY_CONFLICT',
        description: 'æ•°æ®å®Œæ•´æ€§å†²çª',
        resolution_strategy: 'data_validation'
    },
    
    // è´¦å·é‡å¤ï¼šç›¸åŒåŸŸåä¸‹ç”¨æˆ·åå†²çª
    DUPLICATE_CONFLICT: {
        code: 'DUPLICATE_CONFLICT',
        description: 'è´¦å·é‡å¤å†²çª',
        resolution_strategy: 'account_merge'
    }
};
```

## ğŸ”§ æœåŠ¡ç«¯APIå®ç°

### 1. æ•°æ®ä¸Šä¼ æ¥å£ï¼ˆå¸¦å†²çªå¤„ç†ï¼‰
```javascript
// POST /api/sync/data
app.post('/api/sync/data', authenticateToken, async (req, res) => {
    const transaction = await db.beginTransaction();
    
    try {
        const { domainGroup, encryptedData, clientVersion, hash, deviceId, timestamp } = req.body;
        const userId = req.user.id;
        
        // 1. æ•°æ®éªŒè¯
        const validationResult = await validateSyncData(req.body);
        if (!validationResult.valid) {
            return res.status(400).json({
                status: 'error',
                error: 'VALIDATION_FAILED',
                details: validationResult.errors
            });
        }
        
        // 2. è·å–ç°æœ‰æ•°æ®
        const existingData = await SyncData.findOne({
            userId,
            domainGroup
        }, { transaction });
        
        if (!existingData) {
            // 2.1 é¦–æ¬¡ä¸Šä¼ ï¼Œç›´æ¥ä¿å­˜
            const newData = await createSyncData({
                userId,
                domainGroup,
                encryptedData,
                version: generateVersion(),
                dataHash: hash,
                createdByDevice: deviceId,
                updatedByDevice: deviceId
            }, transaction);
            
            await transaction.commit();
            
            return res.json({
                status: 'success',
                data: {
                    version: newData.version,
                    hash: newData.dataHash,
                    timestamp: newData.updatedAt
                }
            });
        }
        
        // 3. å†²çªæ£€æµ‹
        const conflictResult = await detectConflict(existingData, {
            clientVersion,
            hash,
            timestamp,
            deviceId
        });
        
        if (conflictResult.hasConflict) {
            // 4. å†²çªè§£å†³
            const resolution = await resolveConflict(
                existingData,
                { encryptedData, clientVersion, hash, timestamp, deviceId },
                conflictResult.conflictType
            );
            
            // 5. ä¿å­˜è§£å†³ç»“æœ
            await updateSyncData(existingData.id, {
                encryptedData: resolution.resolvedData,
                version: generateVersion(),
                dataHash: resolution.resolvedHash,
                updatedByDevice: deviceId,
                conflictResolution: {
                    type: conflictResult.conflictType,
                    strategy: resolution.strategy,
                    resolvedAt: new Date(),
                    details: resolution.details
                }
            }, transaction);
            
            await transaction.commit();
            
            return res.json({
                status: 'conflict_resolved',
                data: {
                    encryptedData: resolution.resolvedData,
                    version: resolution.version,
                    hash: resolution.resolvedHash,
                    resolutionDetails: {
                        conflictType: conflictResult.conflictType,
                        strategy: resolution.strategy,
                        resolvedAt: new Date()
                    }
                }
            });
        } else {
            // 6. æ— å†²çªï¼Œæ­£å¸¸æ›´æ–°
            await updateSyncData(existingData.id, {
                encryptedData,
                version: generateVersion(),
                dataHash: hash,
                updatedByDevice: deviceId
            }, transaction);
            
            await transaction.commit();
            
            return res.json({
                status: 'success',
                data: {
                    version: existingData.version,
                    hash: hash,
                    timestamp: new Date()
                }
            });
        }
        
    } catch (error) {
        await transaction.rollback();
        console.error('åŒæ­¥æ•°æ®å¤„ç†å¤±è´¥:', error);
        
        return res.status(500).json({
            status: 'error',
            error: 'SYNC_FAILED',
            message: 'æ•°æ®åŒæ­¥å¤„ç†å¤±è´¥'
        });
    }
});
```

### 2. å†²çªæ£€æµ‹ç®—æ³•
```javascript
/**
 * æ£€æµ‹æ•°æ®å†²çª
 * @param {Object} existingData - æœåŠ¡ç«¯ç°æœ‰æ•°æ®
 * @param {Object} clientData - å®¢æˆ·ç«¯ä¸Šä¼ æ•°æ®
 * @returns {Object} å†²çªæ£€æµ‹ç»“æœ
 */
async function detectConflict(existingData, clientData) {
    const result = {
        hasConflict: false,
        conflictType: null,
        details: {}
    };
    
    // 1. å“ˆå¸Œå€¼æ¯”è¾ƒ
    if (existingData.dataHash === clientData.hash) {
        // æ•°æ®ç›¸åŒï¼Œæ— å†²çª
        return result;
    }
    
    // 2. ç‰ˆæœ¬æ¯”è¾ƒ
    const serverTime = new Date(existingData.updatedAt);
    const clientTime = new Date(clientData.timestamp);
    const timeDiff = Math.abs(serverTime - clientTime);
    
    // 3. è®¾å¤‡æ£€æŸ¥
    const sameDevice = existingData.updatedByDevice === clientData.deviceId;
    
    // 4. å†²çªç±»å‹åˆ¤æ–­
    if (existingData.version !== clientData.clientVersion) {
        result.hasConflict = true;
        result.conflictType = CONFLICT_TYPES.VERSION_CONFLICT.code;
        result.details = {
            serverVersion: existingData.version,
            clientVersion: clientData.clientVersion,
            timeDiff: timeDiff
        };
    } else if (timeDiff < 60000 && !sameDevice) {
        // 1åˆ†é’Ÿå†…ä¸åŒè®¾å¤‡ä¿®æ”¹ï¼Œè®¤ä¸ºæ˜¯å¹¶å‘å†²çª
        result.hasConflict = true;
        result.conflictType = CONFLICT_TYPES.CONCURRENT_CONFLICT.code;
        result.details = {
            serverDevice: existingData.updatedByDevice,
            clientDevice: clientData.deviceId,
            timeDiff: timeDiff
        };
    } else {
        // å…¶ä»–æƒ…å†µï¼Œè®¤ä¸ºæ˜¯æ­£å¸¸çš„æ•°æ®æ›´æ–°
        result.hasConflict = true;
        result.conflictType = CONFLICT_TYPES.VERSION_CONFLICT.code;
        result.details = {
            timeDiff: timeDiff,
            sameDevice: sameDevice
        };
    }
    
    return result;
}
```

### 3. å†²çªè§£å†³ç­–ç•¥
```javascript
/**
 * è§£å†³æ•°æ®å†²çª
 * @param {Object} serverData - æœåŠ¡å™¨æ•°æ®
 * @param {Object} clientData - å®¢æˆ·ç«¯æ•°æ® 
 * @param {string} conflictType - å†²çªç±»å‹
 * @returns {Object} è§£å†³ç»“æœ
 */
async function resolveConflict(serverData, clientData, conflictType) {
    const config = await getConflictResolutionConfig();
    
    switch (conflictType) {
        case CONFLICT_TYPES.VERSION_CONFLICT.code:
            return await resolveVersionConflict(serverData, clientData, config);
            
        case CONFLICT_TYPES.CONCURRENT_CONFLICT.code:
            return await resolveConcurrentConflict(serverData, clientData, config);
            
        case CONFLICT_TYPES.DUPLICATE_CONFLICT.code:
            return await resolveDuplicateConflict(serverData, clientData, config);
            
        default:
            return await resolveDefaultConflict(serverData, clientData, config);
    }
}

/**
 * è§£å†³ç‰ˆæœ¬å†²çªï¼ˆæ—¶é—´æˆ³ä¼˜å…ˆï¼‰
 */
async function resolveVersionConflict(serverData, clientData, config) {
    const serverTime = new Date(serverData.updatedAt);
    const clientTime = new Date(clientData.timestamp);
    
    if (clientTime > serverTime) {
        // å®¢æˆ·ç«¯æ•°æ®æ›´æ–°ï¼Œä½¿ç”¨å®¢æˆ·ç«¯æ•°æ®
        return {
            resolvedData: clientData.encryptedData,
            resolvedHash: clientData.hash,
            version: generateVersion(),
            strategy: 'client_wins_by_timestamp',
            details: {
                reason: 'å®¢æˆ·ç«¯æ—¶é—´æˆ³æ›´æ–°',
                serverTime: serverTime,
                clientTime: clientTime
            }
        };
    } else {
        // æœåŠ¡å™¨æ•°æ®æ›´æ–°ï¼Œä¿æŒæœåŠ¡å™¨æ•°æ®
        return {
            resolvedData: serverData.encryptedData,
            resolvedHash: serverData.dataHash,
            version: serverData.version,
            strategy: 'server_wins_by_timestamp',
            details: {
                reason: 'æœåŠ¡å™¨æ—¶é—´æˆ³æ›´æ–°',
                serverTime: serverTime,
                clientTime: clientTime
            }
        };
    }
}

/**
 * è§£å†³å¹¶å‘å†²çªï¼ˆæ™ºèƒ½åˆå¹¶ï¼‰
 */
async function resolveConcurrentConflict(serverData, clientData, config) {
    try {
        // è§£å¯†ä¸¤ä»½æ•°æ®
        const serverDecrypted = await decryptServerData(serverData.encryptedData);
        const clientDecrypted = await decryptServerData(clientData.encryptedData);
        
        // æ™ºèƒ½åˆå¹¶è´¦å·æ•°æ®
        const mergedData = await mergeAccountData(serverDecrypted, clientDecrypted);
        
        // é‡æ–°åŠ å¯†
        const mergedEncrypted = await encryptServerData(mergedData);
        const mergedHash = calculateHash(mergedEncrypted);
        
        return {
            resolvedData: mergedEncrypted,
            resolvedHash: mergedHash,
            version: generateVersion(),
            strategy: 'intelligent_merge',
            details: {
                reason: 'æ™ºèƒ½åˆå¹¶å¹¶å‘ä¿®æ”¹',
                serverAccounts: serverDecrypted.accounts?.length || 0,
                clientAccounts: clientDecrypted.accounts?.length || 0,
                mergedAccounts: mergedData.accounts?.length || 0
            }
        };
        
    } catch (error) {
        console.error('æ™ºèƒ½åˆå¹¶å¤±è´¥ï¼Œå›é€€åˆ°æ—¶é—´æˆ³ç­–ç•¥:', error);
        return await resolveVersionConflict(serverData, clientData, config);
    }
}

/**
 * æ™ºèƒ½åˆå¹¶è´¦å·æ•°æ®
 */
async function mergeAccountData(serverData, clientData) {
    const merged = {
        groupKey: serverData.groupKey || clientData.groupKey,
        baseDomain: serverData.baseDomain || clientData.baseDomain,
        appPackages: [...new Set([
            ...(serverData.appPackages || []),
            ...(clientData.appPackages || [])
        ])],
        accounts: []
    };
    
    // åˆ›å»ºè´¦å·æ˜ å°„
    const accountMap = new Map();
    
    // æ·»åŠ æœåŠ¡å™¨è´¦å·
    (serverData.accounts || []).forEach(account => {
        const key = `${account.username}@${account.subDomain || account.appPackage || 'default'}`;
        accountMap.set(key, {
            ...account,
            source: 'server',
            serverTime: new Date(account.modifyTime)
        });
    });
    
    // åˆå¹¶å®¢æˆ·ç«¯è´¦å·
    (clientData.accounts || []).forEach(account => {
        const key = `${account.username}@${account.subDomain || account.appPackage || 'default'}`;
        const existing = accountMap.get(key);
        
        if (existing) {
            // è´¦å·å†²çªï¼Œé€‰æ‹©è¾ƒæ–°çš„
            const clientTime = new Date(account.modifyTime);
            if (clientTime >= existing.serverTime) {
                accountMap.set(key, {
                    ...account,
                    source: 'client_newer',
                    mergedAt: new Date()
                });
            }
            // å¦åˆ™ä¿æŒæœåŠ¡å™¨ç‰ˆæœ¬
        } else {
            // æ–°è´¦å·ï¼Œç›´æ¥æ·»åŠ 
            accountMap.set(key, {
                ...account,
                source: 'client_new',
                mergedAt: new Date()
            });
        }
    });
    
    // è½¬æ¢ä¸ºæ•°ç»„
    merged.accounts = Array.from(accountMap.values()).map(account => {
        // æ¸…ç†åˆå¹¶å…ƒæ•°æ®
        const { source, serverTime, mergedAt, ...cleanAccount } = account;
        return cleanAccount;
    });
    
    return merged;
}
```

## ğŸ“Š å†²çªè§£å†³é…ç½®

### 1. å…¨å±€é…ç½®
```javascript
const CONFLICT_RESOLUTION_CONFIG = {
    // é»˜è®¤ç­–ç•¥
    default_strategy: 'newer_wins',
    
    // ç­–ç•¥é…ç½®
    strategies: {
        newer_wins: {
            description: 'æ—¶é—´æˆ³è¾ƒæ–°çš„æ•°æ®è·èƒœ',
            priority: 1
        },
        intelligent_merge: {
            description: 'æ™ºèƒ½åˆå¹¶ä¸å†²çªçš„æ•°æ®',
            priority: 2,
            enabled: true,
            fallback: 'newer_wins'
        },
        server_wins: {
            description: 'æœåŠ¡å™¨æ•°æ®ä¼˜å…ˆ',
            priority: 3
        },
        last_writer_wins: {
            description: 'æœ€åå†™å…¥è€…è·èƒœ',
            priority: 4
        }
    },
    
    // å†²çªé˜ˆå€¼
    thresholds: {
        concurrent_time_window: 60000,  // å¹¶å‘å†²çªæ—¶é—´çª—å£ï¼ˆæ¯«ç§’ï¼‰
        max_merge_accounts: 1000,       // æœ€å¤§åˆå¹¶è´¦å·æ•°
        version_tolerance: 5            // ç‰ˆæœ¬å®¹å·®
    }
};
```

### 2. ç”¨æˆ·è‡ªå®šä¹‰ç­–ç•¥
```javascript
// å…è®¸ç”¨æˆ·é…ç½®å†²çªè§£å†³åå¥½
const USER_CONFLICT_PREFERENCES = {
    userId: 'user-uuid',
    preferences: {
        default_strategy: 'intelligent_merge',
        allow_data_loss: false,          // æ˜¯å¦å…è®¸æ•°æ®ä¸¢å¤±
        prefer_local_changes: true,      // æ˜¯å¦åå¥½æœ¬åœ°ä¿®æ”¹
        auto_resolve_duplicates: true,   // è‡ªåŠ¨è§£å†³é‡å¤è´¦å·
        merge_timeout_ms: 30000         // åˆå¹¶è¶…æ—¶æ—¶é—´
    },
    domain_specific: {
        'sensitive-domain.com': {
            strategy: 'manual_review',   // æ•æ„ŸåŸŸåéœ€è¦æ‰‹åŠ¨å®¡æ ¸
            require_confirmation: true
        }
    }
};
```

## ğŸ” ç›‘æ§å’Œæ—¥å¿—

### 1. å†²çªç»Ÿè®¡
```javascript
// å†²çªç»Ÿè®¡æ•°æ®ç»“æ„
const CONFLICT_METRICS = {
    daily_conflicts: {
        date: '2025-01-01',
        total_conflicts: 150,
        by_type: {
            version_conflict: 80,
            concurrent_conflict: 50,
            duplicate_conflict: 20
        },
        by_strategy: {
            newer_wins: 90,
            intelligent_merge: 45,
            server_wins: 15
        },
        resolution_success_rate: 0.95
    },
    
    user_conflict_frequency: {
        high_conflict_users: ['user1', 'user2'],
        average_conflicts_per_user: 2.3,
        max_conflicts_single_user: 15
    }
};
```

### 2. å†²çªå®¡è®¡æ—¥å¿—
```javascript
// å†²çªè§£å†³å®¡è®¡è®°å½•
const CONFLICT_AUDIT_LOG = {
    id: 'audit-uuid',
    userId: 'user-uuid',
    domainGroup: 'example.com',
    conflictType: 'CONCURRENT_CONFLICT',
    detectedAt: '2025-01-01T12:00:00Z',
    resolvedAt: '2025-01-01T12:00:05Z',
    resolution: {
        strategy: 'intelligent_merge',
        dataChanges: {
            accounts_added: 2,
            accounts_modified: 1,
            accounts_removed: 0
        },
        confidence_score: 0.85
    },
    devices_involved: ['device1', 'device2'],
    data_hash_before: 'hash1',
    data_hash_after: 'hash2'
};
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–

### 1. å†²çªæ£€æµ‹ä¼˜åŒ–
```javascript
// ä½¿ç”¨Redisç¼“å­˜å‡å°‘æ•°æ®åº“æŸ¥è¯¢
class ConflictDetectionCache {
    constructor() {
        this.redis = new Redis(config.redis);
        this.cache_ttl = 300; // 5åˆ†é’Ÿç¼“å­˜
    }
    
    async getCachedData(userId, domainGroup) {
        const key = `sync:${userId}:${domainGroup}`;
        const cached = await this.redis.get(key);
        return cached ? JSON.parse(cached) : null;
    }
    
    async setCachedData(userId, domainGroup, data) {
        const key = `sync:${userId}:${domainGroup}`;
        await this.redis.setex(key, this.cache_ttl, JSON.stringify(data));
    }
}
```

### 2. æ‰¹é‡å†²çªå¤„ç†
```javascript
// æ‰¹é‡å¤„ç†å¤šä¸ªåŸŸåçš„å†²çª
app.post('/api/sync/batch', authenticateToken, async (req, res) => {
    const { domains } = req.body;
    const results = [];
    
    // å¹¶å‘å¤„ç†å¤šä¸ªåŸŸå
    const promises = domains.map(async (domainData) => {
        try {
            const result = await processSingleDomain(domainData, req.user.id);
            return { domain: domainData.domainGroup, ...result };
        } catch (error) {
            return { 
                domain: domainData.domainGroup, 
                status: 'error', 
                error: error.message 
            };
        }
    });
    
    const batchResults = await Promise.allSettled(promises);
    
    res.json({
        status: 'batch_completed',
        results: batchResults.map(r => r.value || { status: 'error', error: r.reason })
    });
});
```

è¿™ä¸ªæœåŠ¡ç«¯å†²çªå¤„ç†æ–¹æ¡ˆç¡®ä¿äº†ï¼š

1. **ç»Ÿä¸€çš„å†²çªè§£å†³ç­–ç•¥**ï¼šæ‰€æœ‰å®¢æˆ·ç«¯éµå¾ªç›¸åŒçš„è§„åˆ™
2. **æ™ºèƒ½çš„æ•°æ®åˆå¹¶**ï¼šè‡ªåŠ¨å¤„ç†å¤§éƒ¨åˆ†å†²çªåœºæ™¯
3. **å®Œæ•´çš„å®¡è®¡è¿½è¸ª**ï¼šè®°å½•æ‰€æœ‰å†²çªå’Œè§£å†³è¿‡ç¨‹
4. **é«˜æ€§èƒ½å¤„ç†**ï¼šä¼˜åŒ–çš„ç®—æ³•å’Œç¼“å­˜æœºåˆ¶
5. **çµæ´»çš„é…ç½®**ï¼šæ”¯æŒç”¨æˆ·è‡ªå®šä¹‰å’ŒåŸŸåç‰¹å®šç­–ç•¥

å®¢æˆ·ç«¯åªéœ€è¦ç®€å•åœ°ä¸Šä¼ æ•°æ®å¹¶åº”ç”¨æœåŠ¡ç«¯çš„å†³ç­–ï¼Œå¤§å¤§ç®€åŒ–äº†å®ç°å¤æ‚åº¦ã€‚ 