# æç®€åŒæ­¥æœåŠ¡ç«¯ç¤ºä¾‹

## ğŸš€ å¿«é€Ÿéƒ¨ç½²

### 1. åˆ›å»ºé¡¹ç›®ç›®å½•
```bash
mkdir password-sync-server
cd password-sync-server
```

### 2. åˆå§‹åŒ–é¡¹ç›®
```bash
npm init -y
npm install express cors sqlite3 sequelize
```

### 3. åˆ›å»ºæœåŠ¡å™¨æ–‡ä»¶ (server.js)
```javascript
const express = require('express');
const cors = require('cors');
const { Sequelize, DataTypes } = require('sequelize');
const crypto = require('crypto');

const app = express();
const PORT = process.env.PORT || 3000;

// ä¸­é—´ä»¶
app.use(cors());
app.use(express.json({ limit: '10mb' }));

// æ•°æ®åº“è¿æ¥ï¼ˆSQLiteï¼‰
const sequelize = new Sequelize({
    dialect: 'sqlite',
    storage: process.env.DB_PATH || './sync.db',
    logging: false
});

// æ•°æ®æ¨¡å‹
const SyncData = sequelize.define('SyncData', {
    id: {
        type: DataTypes.UUID,
        defaultValue: DataTypes.UUIDV4,
        primaryKey: true
    },
    domainGroup: {
        type: DataTypes.STRING,
        unique: true,
        allowNull: false
    },
    encryptedData: {
        type: DataTypes.TEXT,
        allowNull: false
    },
    dataHash: {
        type: DataTypes.STRING(64),
        allowNull: false
    },
    lastModified: {
        type: DataTypes.DATE,
        allowNull: false
    }
});

// å·¥å…·å‡½æ•°
function generateUUID() {
    return crypto.randomUUID();
}

// APIè·¯ç”±

/**
 * è·å–åŸŸåç»„æ•°æ®
 */
app.get('/api/sync/:domainGroup', async (req, res) => {
    try {
        const { domainGroup } = req.params;
        
        const data = await SyncData.findOne({
            where: { domainGroup }
        });
        
        if (!data) {
            return res.status(404).json({
                status: 'not_found',
                message: 'åŸŸåç»„æ•°æ®ä¸å­˜åœ¨'
            });
        }
        
        res.json({
            status: 'success',
            data: {
                domainGroup: data.domainGroup,
                encryptedData: JSON.parse(data.encryptedData),
                lastModified: data.lastModified.toISOString(),
                hash: data.dataHash
            }
        });
        
    } catch (error) {
        console.error('è·å–æ•°æ®å¤±è´¥:', error);
        res.status(500).json({
            status: 'error',
            message: 'æœåŠ¡å™¨é”™è¯¯'
        });
    }
});

/**
 * ä¸Šä¼ åŸŸåç»„æ•°æ®ï¼ˆæ—¶é—´æˆ³å†²çªè§£å†³ï¼‰
 */
app.post('/api/sync/:domainGroup', async (req, res) => {
    try {
        const { domainGroup } = req.params;
        const { encryptedData, lastModified, hash } = req.body;
        
        // éªŒè¯å¿…è¦å­—æ®µ
        if (!encryptedData || !lastModified || !hash) {
            return res.status(400).json({
                status: 'error',
                message: 'ç¼ºå°‘å¿…è¦å­—æ®µï¼šencryptedData, lastModified, hash'
            });
        }
        
        const clientTime = new Date(lastModified);
        
        // éªŒè¯æ—¶é—´æ ¼å¼
        if (isNaN(clientTime.getTime())) {
            return res.status(400).json({
                status: 'error',
                message: 'lastModified æ—¶é—´æ ¼å¼æ— æ•ˆ'
            });
        }
        
        // æŸ¥æ‰¾ç°æœ‰æ•°æ®
        const existingData = await SyncData.findOne({
            where: { domainGroup }
        });
        
        if (!existingData) {
            // é¦–æ¬¡ä¸Šä¼ 
            await SyncData.create({
                id: generateUUID(),
                domainGroup,
                encryptedData: JSON.stringify(encryptedData),
                dataHash: hash,
                lastModified: clientTime
            });
            
            return res.json({
                status: 'success',
                data: {
                    domainGroup,
                    lastModified: clientTime.toISOString(),
                    hash
                }
            });
        }
        
        const serverTime = new Date(existingData.lastModified);
        
        // æ—¶é—´æˆ³æ¯”è¾ƒï¼ˆç²¾ç¡®åˆ°ç§’ï¼‰
        const clientTimeSeconds = Math.floor(clientTime.getTime() / 1000);
        const serverTimeSeconds = Math.floor(serverTime.getTime() / 1000);
        
        if (clientTimeSeconds > serverTimeSeconds) {
            // å®¢æˆ·ç«¯æ•°æ®æ›´æ–°ï¼Œæ›´æ–°æœåŠ¡ç«¯æ•°æ®
            await SyncData.update({
                encryptedData: JSON.stringify(encryptedData),
                dataHash: hash,
                lastModified: clientTime
            }, {
                where: { domainGroup }
            });
            
            return res.json({
                status: 'success',
                data: {
                    domainGroup,
                    lastModified: clientTime.toISOString(),
                    hash
                }
            });
        } else if (serverTimeSeconds > clientTimeSeconds) {
            // æœåŠ¡ç«¯æ•°æ®æ›´æ–°ï¼Œè¿”å›æœåŠ¡ç«¯æ•°æ®
            return res.json({
                status: 'conflict_resolved',
                data: {
                    domainGroup: existingData.domainGroup,
                    encryptedData: JSON.parse(existingData.encryptedData),
                    lastModified: existingData.lastModified.toISOString(),
                    hash: existingData.dataHash
                }
            });
        } else {
            // æ—¶é—´ç›¸åŒï¼Œæ¯”è¾ƒå“ˆå¸Œ
            if (hash === existingData.dataHash) {
                // æ•°æ®ç›¸åŒ
                return res.json({
                    status: 'success',
                    data: {
                        domainGroup,
                        lastModified: serverTime.toISOString(),
                        hash
                    }
                });
            } else {
                // æ—¶é—´ç›¸åŒä½†æ•°æ®ä¸åŒï¼Œä¿æŒæœåŠ¡ç«¯æ•°æ®
                return res.json({
                    status: 'conflict_resolved',
                    data: {
                        domainGroup: existingData.domainGroup,
                        encryptedData: JSON.parse(existingData.encryptedData),
                        lastModified: existingData.lastModified.toISOString(),
                        hash: existingData.dataHash
                    }
                });
            }
        }
        
    } catch (error) {
        console.error('ä¸Šä¼ æ•°æ®å¤±è´¥:', error);
        res.status(500).json({
            status: 'error',
            message: 'æœåŠ¡å™¨é”™è¯¯'
        });
    }
});

/**
 * åˆ é™¤åŸŸåç»„æ•°æ®
 */
app.delete('/api/sync/:domainGroup', async (req, res) => {
    try {
        const { domainGroup } = req.params;
        
        const deleted = await SyncData.destroy({
            where: { domainGroup }
        });
        
        if (deleted === 0) {
            return res.status(404).json({
                status: 'not_found',
                message: 'åŸŸåç»„æ•°æ®ä¸å­˜åœ¨'
            });
        }
        
        res.json({
            status: 'success',
            message: 'æ•°æ®å·²åˆ é™¤'
        });
        
    } catch (error) {
        console.error('åˆ é™¤æ•°æ®å¤±è´¥:', error);
        res.status(500).json({
            status: 'error',
            message: 'æœåŠ¡å™¨é”™è¯¯'
        });
    }
});

/**
 * è·å–æ‰€æœ‰åŸŸåç»„åˆ—è¡¨
 */
app.get('/api/sync', async (req, res) => {
    try {
        const data = await SyncData.findAll({
            attributes: ['domainGroup', 'lastModified', 'dataHash']
        });
        
        res.json({
            status: 'success',
            data: data.map(item => ({
                domainGroup: item.domainGroup,
                lastModified: item.lastModified.toISOString(),
                hash: item.dataHash
            }))
        });
        
    } catch (error) {
        console.error('è·å–åŸŸåç»„åˆ—è¡¨å¤±è´¥:', error);
        res.status(500).json({
            status: 'error',
            message: 'æœåŠ¡å™¨é”™è¯¯'
        });
    }
});

/**
 * å¥åº·æ£€æŸ¥
 */
app.get('/health', (req, res) => {
    res.json({
        status: 'ok',
        timestamp: new Date().toISOString(),
        version: '1.0.0'
    });
});

// å¯åŠ¨æœåŠ¡å™¨
async function start() {
    try {
        // åŒæ­¥æ•°æ®åº“
        await sequelize.sync();
        console.log('æ•°æ®åº“åŒæ­¥å®Œæˆ');
        
        app.listen(PORT, () => {
            console.log(`æç®€åŒæ­¥æœåŠ¡å™¨è¿è¡Œåœ¨ç«¯å£ ${PORT}`);
            console.log(`å¥åº·æ£€æŸ¥: http://localhost:${PORT}/health`);
        });
    } catch (error) {
        console.error('å¯åŠ¨æœåŠ¡å™¨å¤±è´¥:', error);
        process.exit(1);
    }
}

// ä¼˜é›…å…³é—­
process.on('SIGTERM', async () => {
    console.log('æ­£åœ¨å…³é—­æœåŠ¡å™¨...');
    await sequelize.close();
    process.exit(0);
});

process.on('SIGINT', async () => {
    console.log('æ­£åœ¨å…³é—­æœåŠ¡å™¨...');
    await sequelize.close();
    process.exit(0);
});

start().catch(console.error);
```

### 4. åˆ›å»º package.json è„šæœ¬
```json
{
  "name": "password-sync-server",
  "version": "1.0.0",
  "description": "æç®€å¯†ç åŒæ­¥æœåŠ¡å™¨",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "sqlite3": "^5.1.6",
    "sequelize": "^6.32.1"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  }
}
```

### 5. åˆ›å»º Docker é…ç½® (Dockerfile)
```dockerfile
FROM node:18-alpine

WORKDIR /app

# å¤åˆ¶ package.json å’Œ package-lock.json
COPY package*.json ./

# å®‰è£…ä¾èµ–
RUN npm install --production

# å¤åˆ¶æºä»£ç 
COPY . .

# æš´éœ²ç«¯å£
EXPOSE 3000

# å¯åŠ¨åº”ç”¨
CMD ["node", "server.js"]
```

### 6. åˆ›å»º docker-compose.yml
```yaml
version: '3.8'

services:
  sync-server:
    build: .
    ports:
      - "3000:3000"
    volumes:
      - ./data:/app/data
    environment:
      - PORT=3000
      - DB_PATH=/app/data/sync.db
    restart: unless-stopped
```

## ğŸš€ éƒ¨ç½²æ–¹å¼

### æ–¹å¼ä¸€ï¼šæœ¬åœ°è¿è¡Œ
```bash
# å®‰è£…ä¾èµ–
npm install

# å¯åŠ¨æœåŠ¡å™¨
npm start

# æˆ–å¼€å‘æ¨¡å¼
npm run dev
```

### æ–¹å¼äºŒï¼šDocker éƒ¨ç½²
```bash
# æ„å»ºé•œåƒ
docker build -t password-sync-server .

# è¿è¡Œå®¹å™¨
docker run -d \
  --name password-sync \
  -p 3000:3000 \
  -v $(pwd)/data:/app/data \
  password-sync-server
```

### æ–¹å¼ä¸‰ï¼šDocker Compose
```bash
# å¯åŠ¨æœåŠ¡
docker-compose up -d

# æŸ¥çœ‹æ—¥å¿—
docker-compose logs -f

# åœæ­¢æœåŠ¡
docker-compose down
```

## ğŸ”§ ç¯å¢ƒå˜é‡

| å˜é‡å | é»˜è®¤å€¼ | è¯´æ˜ |
|--------|--------|------|
| `PORT` | `3000` | æœåŠ¡å™¨ç«¯å£ |
| `DB_PATH` | `./sync.db` | SQLite æ•°æ®åº“æ–‡ä»¶è·¯å¾„ |

## ğŸ“‹ API æ–‡æ¡£

### è·å–æ•°æ®
```
GET /api/sync/{domainGroup}
```

### ä¸Šä¼ æ•°æ®
```
POST /api/sync/{domainGroup}
Content-Type: application/json

{
  "encryptedData": {...},
  "lastModified": "2025-01-01T12:30:00.000Z",
  "hash": "abc123..."
}
```

### è·å–æ‰€æœ‰åŸŸåç»„
```
GET /api/sync
```

### åˆ é™¤æ•°æ®
```
DELETE /api/sync/{domainGroup}
```

### å¥åº·æ£€æŸ¥
```
GET /health
```

## ğŸ”’ å®‰å…¨å»ºè®®

### 1. HTTPS éƒ¨ç½²
```nginx
server {
    listen 443 ssl;
    server_name your-domain.com;
    
    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/key.pem;
    
    location / {
        proxy_pass http://localhost:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

### 2. é˜²ç«å¢™é…ç½®
```bash
# åªå…è®¸å¿…è¦ç«¯å£
ufw allow 22    # SSH
ufw allow 80    # HTTP
ufw allow 443   # HTTPS
ufw enable
```

### 3. é€Ÿç‡é™åˆ¶
å¯ä»¥ä½¿ç”¨ nginx çš„ `limit_req` æ¨¡å—ï¼š
```nginx
http {
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/m;
    
    server {
        location /api/ {
            limit_req zone=api burst=5;
            proxy_pass http://localhost:3000;
        }
    }
}
```

## ğŸ” ç›‘æ§å’Œæ—¥å¿—

### 1. æ·»åŠ æ—¥å¿—ä¸­é—´ä»¶
```javascript
app.use((req, res, next) => {
    console.log(`${new Date().toISOString()} ${req.method} ${req.url}`);
    next();
});
```

### 2. ä½¿ç”¨ PM2 ç®¡ç†è¿›ç¨‹
```bash
npm install -g pm2

# å¯åŠ¨åº”ç”¨
pm2 start server.js --name password-sync

# æŸ¥çœ‹çŠ¶æ€
pm2 status

# æŸ¥çœ‹æ—¥å¿—
pm2 logs password-sync
```

è¿™ä¸ªæç®€æœåŠ¡å™¨ä¸“é—¨ä¸ºä¸ªäººä½¿ç”¨è®¾è®¡ï¼Œæä¾›äº†åŸºæœ¬çš„åŒæ­¥åŠŸèƒ½ï¼ŒåŒæ—¶ä¿æŒäº†ä»£ç çš„ç®€æ´æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚ 