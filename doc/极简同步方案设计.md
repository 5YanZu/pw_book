# æç®€ä¸ªäººåŒæ­¥æ–¹æ¡ˆè®¾è®¡

## ğŸ¯ è®¾è®¡åŸåˆ™

### æ ¸å¿ƒç†å¿µ
- **æ—¶é—´æˆ³ä¼˜å…ˆ**ï¼šä½¿ç”¨æ›´æ–°æ—¶é—´è§£å†³å†²çªï¼Œä¿ç•™æœ€æ–°æ•°æ®
- **æ— è®¤è¯è®¾è®¡**ï¼šä¸ªäººä½¿ç”¨ï¼Œæ— éœ€ç™»å½•è®¤è¯
- **æç®€æ¶æ„**ï¼šä¸ç»´æŠ¤è®¾å¤‡ä¿¡æ¯ã€åŒæ­¥å†å²ç­‰å¤æ‚æ•°æ®
- **éå¯¹ç§°åŠ å¯†**ï¼šå®¢æˆ·ç«¯é…ç½®å¯†é’¥ï¼Œä¿è¯æ•°æ®å®‰å…¨

## ğŸ—ï¸ ç®€åŒ–æ•°æ®ç»“æ„

### 1. å®¢æˆ·ç«¯æ•°æ®ç»“æ„
```json
{
    "baidu.com": {
        "groupKey": "baidu.com",
        "baseDomain": "baidu.com", 
        "appPackages": ["com.baidu.a"],
        "lastModified": "2025-01-01T12:30:00.000Z",
        "accounts": [{
            "id": "uuid-1234-5678-9012",
            "subDomain": "pan.baidu.com",
            "appPackage": null,
            "username": "admin",
            "password": "encrypted_password",
            "source": "æ’ä»¶",
            "createdTime": "2025-01-01T12:00:00.000Z",
            "modifyTime": "2025-01-01T12:30:00.000Z"
        }]
    }
}
```

### 2. æœåŠ¡ç«¯æ•°æ®ç»“æ„
```sql
CREATE TABLE sync_data (
    id VARCHAR(36) PRIMARY KEY,
    domain_group VARCHAR(255) UNIQUE NOT NULL,
    encrypted_data TEXT NOT NULL,
    data_hash VARCHAR(64) NOT NULL,
    last_modified TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

### 3. å®¢æˆ·ç«¯å¯†é’¥é…ç½®
```json
{
    "syncSettings": {
        "enabled": true,
        "serverUrl": "https://your-sync-server.com",
        "autoSync": true,
        "syncInterval": 300000,
        "publicKey": "-----BEGIN PUBLIC KEY-----\n...\n-----END PUBLIC KEY-----",
        "privateKey": "-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"
    }
}
```

## ğŸ” ç®€åŒ–åŠ å¯†æ–¹æ¡ˆ

### 1. éå¯¹ç§°åŠ å¯†å®ç°
```javascript
class SimpleCryptoManager {
    constructor() {
        this.publicKey = null;
        this.privateKey = null;
    }
    
    /**
     * ç”Ÿæˆå¯†é’¥å¯¹
     */
    async generateKeyPair() {
        const keyPair = await crypto.subtle.generateKey(
            {
                name: 'RSA-OAEP',
                modulusLength: 2048,
                publicExponent: new Uint8Array([1, 0, 1]),
                hash: 'SHA-256'
            },
            true,
            ['encrypt', 'decrypt']
        );
        
        return {
            publicKey: await this.exportKey(keyPair.publicKey, 'spki'),
            privateKey: await this.exportKey(keyPair.privateKey, 'pkcs8')
        };
    }
    
    /**
     * å¯¼å…¥å¯†é’¥
     */
    async importKeys(publicKeyPem, privateKeyPem) {
        this.publicKey = await crypto.subtle.importKey(
            'spki',
            this.pemToBuffer(publicKeyPem),
            { name: 'RSA-OAEP', hash: 'SHA-256' },
            false,
            ['encrypt']
        );
        
        this.privateKey = await crypto.subtle.importKey(
            'pkcs8', 
            this.pemToBuffer(privateKeyPem),
            { name: 'RSA-OAEP', hash: 'SHA-256' },
            false,
            ['decrypt']
        );
    }
    
    /**
     * åŠ å¯†æ•°æ®
     */
    async encrypt(data) {
        const encoder = new TextEncoder();
        const dataBuffer = encoder.encode(JSON.stringify(data));
        
        // RSAåŠ å¯†æœ‰é•¿åº¦é™åˆ¶ï¼Œå¯¹äºå¤§æ•°æ®ä½¿ç”¨æ··åˆåŠ å¯†
        if (dataBuffer.length > 190) { // RSA-2048çš„æœ€å¤§åŠ å¯†é•¿åº¦çº¦ä¸º245å­—èŠ‚
            return await this.hybridEncrypt(data);
        }
        
        const encrypted = await crypto.subtle.encrypt(
            { name: 'RSA-OAEP' },
            this.publicKey,
            dataBuffer
        );
        
        return this.arrayBufferToBase64(encrypted);
    }
    
    /**
     * è§£å¯†æ•°æ®
     */
    async decrypt(encryptedData) {
        if (typeof encryptedData === 'object' && encryptedData.type === 'hybrid') {
            return await this.hybridDecrypt(encryptedData);
        }
        
        const encrypted = this.base64ToArrayBuffer(encryptedData);
        const decrypted = await crypto.subtle.decrypt(
            { name: 'RSA-OAEP' },
            this.privateKey,
            encrypted
        );
        
        const decoder = new TextDecoder();
        return JSON.parse(decoder.decode(decrypted));
    }
    
    /**
     * æ··åˆåŠ å¯†ï¼ˆRSA + AESï¼‰
     */
    async hybridEncrypt(data) {
        // ç”ŸæˆAESå¯†é’¥
        const aesKey = await crypto.subtle.generateKey(
            { name: 'AES-GCM', length: 256 },
            true,
            ['encrypt', 'decrypt']
        );
        
        // ç”¨AESåŠ å¯†æ•°æ®
        const encoder = new TextEncoder();
        const dataBuffer = encoder.encode(JSON.stringify(data));
        const iv = crypto.getRandomValues(new Uint8Array(12));
        
        const encryptedData = await crypto.subtle.encrypt(
            { name: 'AES-GCM', iv: iv },
            aesKey,
            dataBuffer
        );
        
        // å¯¼å‡ºAESå¯†é’¥
        const exportedKey = await crypto.subtle.exportKey('raw', aesKey);
        
        // ç”¨RSAåŠ å¯†AESå¯†é’¥
        const encryptedKey = await crypto.subtle.encrypt(
            { name: 'RSA-OAEP' },
            this.publicKey,
            exportedKey
        );
        
        return {
            type: 'hybrid',
            encryptedKey: this.arrayBufferToBase64(encryptedKey),
            encryptedData: this.arrayBufferToBase64(encryptedData),
            iv: this.arrayBufferToBase64(iv)
        };
    }
    
    /**
     * æ··åˆè§£å¯†
     */
    async hybridDecrypt(encryptedPackage) {
        // è§£å¯†AESå¯†é’¥
        const encryptedKey = this.base64ToArrayBuffer(encryptedPackage.encryptedKey);
        const keyBuffer = await crypto.subtle.decrypt(
            { name: 'RSA-OAEP' },
            this.privateKey,
            encryptedKey
        );
        
        // å¯¼å…¥AESå¯†é’¥
        const aesKey = await crypto.subtle.importKey(
            'raw',
            keyBuffer,
            { name: 'AES-GCM' },
            false,
            ['decrypt']
        );
        
        // è§£å¯†æ•°æ®
        const encryptedData = this.base64ToArrayBuffer(encryptedPackage.encryptedData);
        const iv = this.base64ToArrayBuffer(encryptedPackage.iv);
        
        const decrypted = await crypto.subtle.decrypt(
            { name: 'AES-GCM', iv: iv },
            aesKey,
            encryptedData
        );
        
        const decoder = new TextDecoder();
        return JSON.parse(decoder.decode(decrypted));
    }
    
    // å·¥å…·æ–¹æ³•
    pemToBuffer(pem) {
        const base64 = pem
            .replace(/-----BEGIN.*?-----/, '')
            .replace(/-----END.*?-----/, '')
            .replace(/\s/g, '');
        return this.base64ToArrayBuffer(base64);
    }
    
    async exportKey(key, format) {
        const exported = await crypto.subtle.exportKey(format, key);
        const base64 = this.arrayBufferToBase64(exported);
        const type = format === 'spki' ? 'PUBLIC' : 'PRIVATE';
        return `-----BEGIN ${type} KEY-----\n${base64}\n-----END ${type} KEY-----`;
    }
    
    arrayBufferToBase64(buffer) {
        const bytes = new Uint8Array(buffer);
        let binary = '';
        for (let i = 0; i < bytes.byteLength; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    }
    
    base64ToArrayBuffer(base64) {
        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
            bytes[i] = binary.charCodeAt(i);
        }
        return bytes.buffer;
    }
}
```

## ğŸ“¡ ç®€åŒ–APIè®¾è®¡

### 1. æœåŠ¡ç«¯APIï¼ˆæ— è®¤è¯ï¼‰
```javascript
// è·å–æ•°æ®
app.get('/api/sync/:domainGroup', async (req, res) => {
    try {
        const { domainGroup } = req.params;
        
        const data = await SyncData.findOne({
            where: { domainGroup }
        });
        
        if (!data) {
            return res.status(404).json({
                status: 'not_found',
                message: 'åŸŸåç»„æ•°æ®ä¸å­˜åœ¨'
            });
        }
        
        res.json({
            status: 'success',
            data: {
                domainGroup: data.domainGroup,
                encryptedData: data.encryptedData,
                lastModified: data.lastModified,
                hash: data.dataHash
            }
        });
        
    } catch (error) {
        console.error('è·å–æ•°æ®å¤±è´¥:', error);
        res.status(500).json({
            status: 'error',
            message: 'æœåŠ¡å™¨é”™è¯¯'
        });
    }
});

// ä¸Šä¼ æ•°æ®ï¼ˆæ—¶é—´æˆ³å†²çªè§£å†³ï¼‰
app.post('/api/sync/:domainGroup', async (req, res) => {
    try {
        const { domainGroup } = req.params;
        const { encryptedData, lastModified, hash } = req.body;
        
        // éªŒè¯å¿…è¦å­—æ®µ
        if (!encryptedData || !lastModified || !hash) {
            return res.status(400).json({
                status: 'error',
                message: 'ç¼ºå°‘å¿…è¦å­—æ®µ'
            });
        }
        
        const clientTime = new Date(lastModified);
        
        // æŸ¥æ‰¾ç°æœ‰æ•°æ®
        const existingData = await SyncData.findOne({
            where: { domainGroup }
        });
        
        if (!existingData) {
            // é¦–æ¬¡ä¸Šä¼ 
            await SyncData.create({
                id: generateUUID(),
                domainGroup,
                encryptedData,
                dataHash: hash,
                lastModified: clientTime
            });
            
            return res.json({
                status: 'success',
                data: {
                    domainGroup,
                    lastModified: clientTime,
                    hash
                }
            });
        }
        
        const serverTime = new Date(existingData.lastModified);
        
        // æ—¶é—´æˆ³æ¯”è¾ƒ
        if (clientTime > serverTime) {
            // å®¢æˆ·ç«¯æ•°æ®æ›´æ–°ï¼Œæ›´æ–°æœåŠ¡ç«¯æ•°æ®
            await SyncData.update({
                encryptedData,
                dataHash: hash,
                lastModified: clientTime
            }, {
                where: { domainGroup }
            });
            
            return res.json({
                status: 'success',
                data: {
                    domainGroup,
                    lastModified: clientTime,
                    hash
                }
            });
        } else if (serverTime > clientTime) {
            // æœåŠ¡ç«¯æ•°æ®æ›´æ–°ï¼Œè¿”å›æœåŠ¡ç«¯æ•°æ®
            return res.json({
                status: 'conflict_resolved',
                data: {
                    domainGroup: existingData.domainGroup,
                    encryptedData: existingData.encryptedData,
                    lastModified: existingData.lastModified,
                    hash: existingData.dataHash
                }
            });
        } else {
            // æ—¶é—´ç›¸åŒï¼Œæ¯”è¾ƒå“ˆå¸Œ
            if (hash === existingData.dataHash) {
                // æ•°æ®ç›¸åŒ
                return res.json({
                    status: 'success',
                    data: {
                        domainGroup,
                        lastModified: serverTime,
                        hash
                    }
                });
            } else {
                // æ—¶é—´ç›¸åŒä½†æ•°æ®ä¸åŒï¼Œä¿æŒæœåŠ¡ç«¯æ•°æ®
                return res.json({
                    status: 'conflict_resolved',
                    data: {
                        domainGroup: existingData.domainGroup,
                        encryptedData: existingData.encryptedData,
                        lastModified: existingData.lastModified,
                        hash: existingData.dataHash
                    }
                });
            }
        }
        
    } catch (error) {
        console.error('ä¸Šä¼ æ•°æ®å¤±è´¥:', error);
        res.status(500).json({
            status: 'error',
            message: 'æœåŠ¡å™¨é”™è¯¯'
        });
    }
});

// åˆ é™¤æ•°æ®
app.delete('/api/sync/:domainGroup', async (req, res) => {
    try {
        const { domainGroup } = req.params;
        
        await SyncData.destroy({
            where: { domainGroup }
        });
        
        res.json({
            status: 'success',
            message: 'æ•°æ®å·²åˆ é™¤'
        });
        
    } catch (error) {
        console.error('åˆ é™¤æ•°æ®å¤±è´¥:', error);
        res.status(500).json({
            status: 'error',
            message: 'æœåŠ¡å™¨é”™è¯¯'
        });
    }
});

// è·å–æ‰€æœ‰åŸŸåç»„åˆ—è¡¨
app.get('/api/sync', async (req, res) => {
    try {
        const data = await SyncData.findAll({
            attributes: ['domainGroup', 'lastModified', 'dataHash']
        });
        
        res.json({
            status: 'success',
            data: data.map(item => ({
                domainGroup: item.domainGroup,
                lastModified: item.lastModified,
                hash: item.dataHash
            }))
        });
        
    } catch (error) {
        console.error('è·å–åŸŸåç»„åˆ—è¡¨å¤±è´¥:', error);
        res.status(500).json({
            status: 'error',
            message: 'æœåŠ¡å™¨é”™è¯¯'
        });
    }
});
```

## ğŸ”„ ç®€åŒ–å®¢æˆ·ç«¯åŒæ­¥é€»è¾‘

### 1. æç®€åŒæ­¥ç®¡ç†å™¨
```javascript
class SimpleSyncManager {
    constructor() {
        this.serverUrl = null;
        this.cryptoManager = new SimpleCryptoManager();
        this.syncState = 'idle';
        this.syncTimer = null;
    }
    
    /**
     * åˆå§‹åŒ–åŒæ­¥ç®¡ç†å™¨
     */
    async init() {
        try {
            const settings = await this.getSyncSettings();
            this.serverUrl = settings.serverUrl;
            
            if (settings.publicKey && settings.privateKey) {
                await this.cryptoManager.importKeys(settings.publicKey, settings.privateKey);
            }
            
            if (settings.autoSync) {
                this.startPeriodicSync(settings.syncInterval);
            }
            
            console.log('æç®€åŒæ­¥ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ');
        } catch (error) {
            console.error('åŒæ­¥ç®¡ç†å™¨åˆå§‹åŒ–å¤±è´¥:', error);
        }
    }
    
    /**
     * ç”Ÿæˆå¹¶é…ç½®å¯†é’¥
     */
    async generateAndSetupKeys() {
        const keyPair = await this.cryptoManager.generateKeyPair();
        
        const settings = await this.getSyncSettings();
        settings.publicKey = keyPair.publicKey;
        settings.privateKey = keyPair.privateKey;
        await this.saveSyncSettings(settings);
        
        await this.cryptoManager.importKeys(keyPair.publicKey, keyPair.privateKey);
        
        return keyPair;
    }
    
    /**
     * åŒæ­¥æŒ‡å®šåŸŸåç»„
     */
    async syncDomain(domain) {
        try {
            // è·å–æœ¬åœ°æ•°æ®
            const localData = await this.getLocalDomainData(domain);
            
            if (!localData) {
                // æœ¬åœ°æ— æ•°æ®ï¼Œå°è¯•ä»æœåŠ¡ç«¯ä¸‹è½½
                await this.downloadDomainData(domain);
                return;
            }
            
            // ä¸Šä¼ åˆ°æœåŠ¡ç«¯
            const response = await this.uploadDomainData(domain, localData);
            
            if (response.status === 'conflict_resolved') {
                // æœåŠ¡ç«¯æ•°æ®æ›´æ–°ï¼Œåº”ç”¨æœåŠ¡ç«¯æ•°æ®
                const serverData = await this.cryptoManager.decrypt(response.data.encryptedData);
                await this.saveLocalDomainData(domain, serverData, response.data.lastModified);
                console.log(`åŸŸå ${domain}: åº”ç”¨æœåŠ¡ç«¯æœ€æ–°æ•°æ®`);
            } else {
                console.log(`åŸŸå ${domain}: åŒæ­¥æˆåŠŸ`);
            }
            
        } catch (error) {
            console.error(`åŸŸå ${domain} åŒæ­¥å¤±è´¥:`, error);
        }
    }
    
    /**
     * ä¸Šä¼ åŸŸåæ•°æ®
     */
    async uploadDomainData(domain, data) {
        const encryptedData = await this.cryptoManager.encrypt(data);
        const hash = await this.calculateHash(JSON.stringify(data));
        
        const response = await fetch(`${this.serverUrl}/api/sync/${domain}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                encryptedData,
                lastModified: data.lastModified,
                hash
            })
        });
        
        return await response.json();
    }
    
    /**
     * ä¸‹è½½åŸŸåæ•°æ®
     */
    async downloadDomainData(domain) {
        try {
            const response = await fetch(`${this.serverUrl}/api/sync/${domain}`);
            
            if (response.status === 404) {
                console.log(`åŸŸå ${domain}: æœåŠ¡ç«¯æ— æ•°æ®`);
                return;
            }
            
            const result = await response.json();
            
            if (result.status === 'success') {
                const decryptedData = await this.cryptoManager.decrypt(result.data.encryptedData);
                await this.saveLocalDomainData(domain, decryptedData, result.data.lastModified);
                console.log(`åŸŸå ${domain}: ä¸‹è½½æˆåŠŸ`);
            }
            
        } catch (error) {
            console.error(`ä¸‹è½½åŸŸå ${domain} å¤±è´¥:`, error);
        }
    }
    
    /**
     * è·å–æœ¬åœ°åŸŸåæ•°æ®
     */
    async getLocalDomainData(domain) {
        const allAccounts = await storageManager.getAllAccounts();
        const domainData = allAccounts[domain];
        
        if (!domainData) return null;
        
        // æ·»åŠ æœ€åä¿®æ”¹æ—¶é—´
        return {
            ...domainData,
            lastModified: this.getLatestModifyTime(domainData.accounts)
        };
    }
    
    /**
     * ä¿å­˜æœ¬åœ°åŸŸåæ•°æ®
     */
    async saveLocalDomainData(domain, data, lastModified) {
        // æ¸…é™¤ç°æœ‰æ•°æ®
        const existingAccounts = await storageManager.getAccountsByDomain(domain);
        for (const account of existingAccounts) {
            await storageManager.deleteAccount(domain, account.username, account.subDomain);
        }
        
        // ä¿å­˜æ–°æ•°æ®
        for (const account of data.accounts) {
            await storageManager.saveAccount(domain, account, account.password, account.subDomain);
        }
        
        console.log(`åŸŸå ${domain}: æœ¬åœ°æ•°æ®å·²æ›´æ–°`);
    }
    
    /**
     * è·å–æœ€æ–°ä¿®æ”¹æ—¶é—´
     */
    getLatestModifyTime(accounts) {
        let latest = new Date(0);
        for (const account of accounts) {
            const modifyTime = new Date(account.modifyTime);
            if (modifyTime > latest) {
                latest = modifyTime;
            }
        }
        return latest.toISOString();
    }
    
    /**
     * è®¡ç®—æ•°æ®å“ˆå¸Œ
     */
    async calculateHash(data) {
        const encoder = new TextEncoder();
        const dataBuffer = encoder.encode(data);
        const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);
        
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }
    
    /**
     * åŒæ­¥æ‰€æœ‰åŸŸå
     */
    async syncAll() {
        if (this.syncState === 'syncing') return;
        
        this.syncState = 'syncing';
        
        try {
            const allAccounts = await storageManager.getAllAccounts();
            const domains = Object.keys(allAccounts);
            
            for (const domain of domains) {
                await this.syncDomain(domain);
            }
            
            // æ£€æŸ¥æœåŠ¡ç«¯æ˜¯å¦æœ‰æœ¬åœ°æ²¡æœ‰çš„æ•°æ®
            await this.checkServerOnlyDomains();
            
        } catch (error) {
            console.error('å…¨é‡åŒæ­¥å¤±è´¥:', error);
        } finally {
            this.syncState = 'idle';
        }
    }
    
    /**
     * æ£€æŸ¥æœåŠ¡ç«¯ç‹¬æœ‰çš„åŸŸå
     */
    async checkServerOnlyDomains() {
        try {
            const response = await fetch(`${this.serverUrl}/api/sync`);
            const result = await response.json();
            
            if (result.status === 'success') {
                const allAccounts = await storageManager.getAllAccounts();
                const localDomains = Object.keys(allAccounts);
                
                for (const serverDomain of result.data) {
                    if (!localDomains.includes(serverDomain.domainGroup)) {
                        await this.downloadDomainData(serverDomain.domainGroup);
                    }
                }
            }
            
        } catch (error) {
            console.error('æ£€æŸ¥æœåŠ¡ç«¯åŸŸåå¤±è´¥:', error);
        }
    }
    
    /**
     * å¯åŠ¨å®šæ—¶åŒæ­¥
     */
    startPeriodicSync(interval = 300000) {
        if (this.syncTimer) {
            clearInterval(this.syncTimer);
        }
        
        this.syncTimer = setInterval(() => {
            this.syncAll();
        }, interval);
        
        console.log(`å¯åŠ¨å®šæ—¶åŒæ­¥ï¼Œé—´éš”: ${interval}ms`);
    }
    
    /**
     * è·å–åŒæ­¥è®¾ç½®
     */
    async getSyncSettings() {
        const settings = await storageManager.getSettings();
        return settings.syncSettings || {
            enabled: false,
            serverUrl: '',
            autoSync: true,
            syncInterval: 300000,
            publicKey: null,
            privateKey: null
        };
    }
    
    /**
     * ä¿å­˜åŒæ­¥è®¾ç½®
     */
    async saveSyncSettings(syncSettings) {
        const settings = await storageManager.getSettings();
        settings.syncSettings = syncSettings;
        await storageManager.saveSettings(settings);
    }
}

// å…¨å±€å®ä¾‹
const simpleSyncManager = new SimpleSyncManager();
```

## ğŸ›ï¸ å®¢æˆ·ç«¯å¯†é’¥é…ç½®ç•Œé¢

### 1. åŒæ­¥è®¾ç½®UI
```javascript
// åœ¨ popup.js ä¸­æ·»åŠ å¯†é’¥é…ç½®
function renderSyncSettings() {
    return `
        <div class="sync-settings">
            <div class="settings-header">
                <h3>åŒæ­¥è®¾ç½®</h3>
                <div class="sync-status" id="syncStatus">
                    <span class="status-indicator" id="statusIndicator"></span>
                    <span id="statusText">æœªé…ç½®</span>
                </div>
            </div>
            
            <div class="settings-form">
                <div class="form-group">
                    <label>æœåŠ¡å™¨åœ°å€:</label>
                    <input type="url" id="serverUrl" placeholder="https://your-server.com">
                </div>
                
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="autoSync"> è‡ªåŠ¨åŒæ­¥
                    </label>
                </div>
                
                <div class="key-section">
                    <h4>åŠ å¯†å¯†é’¥</h4>
                    <div class="key-actions">
                        <button class="btn btn-secondary" id="generateKeysBtn">ç”Ÿæˆæ–°å¯†é’¥</button>
                        <button class="btn btn-secondary" id="importKeysBtn">å¯¼å…¥å¯†é’¥</button>
                        <button class="btn btn-secondary" id="exportKeysBtn">å¯¼å‡ºå¯†é’¥</button>
                    </div>
                    
                    <div class="key-info" id="keyInfo" style="display:none;">
                        <div class="key-fingerprint">
                            æŒ‡çº¹: <span id="keyFingerprint"></span>
                        </div>
                    </div>
                </div>
                
                <div class="sync-actions">
                    <button class="btn btn-primary" id="saveSyncSettings">ä¿å­˜è®¾ç½®</button>
                    <button class="btn btn-secondary" id="testConnection">æµ‹è¯•è¿æ¥</button>
                    <button class="btn btn-secondary" id="syncNow">ç«‹å³åŒæ­¥</button>
                </div>
            </div>
        </div>
    `;
}

// å¯†é’¥ç®¡ç†äº‹ä»¶
document.addEventListener('DOMContentLoaded', () => {
    // ç”Ÿæˆå¯†é’¥
    document.getElementById('generateKeysBtn')?.addEventListener('click', async () => {
        try {
            const keyPair = await simpleSyncManager.generateAndSetupKeys();
            showNotification('å¯†é’¥ç”ŸæˆæˆåŠŸ', 'success');
            updateKeyInfo();
        } catch (error) {
            showNotification('å¯†é’¥ç”Ÿæˆå¤±è´¥: ' + error.message, 'error');
        }
    });
    
    // å¯¼å‡ºå¯†é’¥
    document.getElementById('exportKeysBtn')?.addEventListener('click', async () => {
        try {
            const settings = await simpleSyncManager.getSyncSettings();
            if (!settings.publicKey || !settings.privateKey) {
                showNotification('è¯·å…ˆç”Ÿæˆå¯†é’¥', 'warning');
                return;
            }
            
            const keyData = {
                publicKey: settings.publicKey,
                privateKey: settings.privateKey,
                exportTime: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(keyData, null, 2)], {
                type: 'application/json'
            });
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `sync-keys-${Date.now()}.json`;
            a.click();
            
            URL.revokeObjectURL(url);
            showNotification('å¯†é’¥å·²å¯¼å‡º', 'success');
            
        } catch (error) {
            showNotification('å¯†é’¥å¯¼å‡ºå¤±è´¥: ' + error.message, 'error');
        }
    });
    
    // å¯¼å…¥å¯†é’¥
    document.getElementById('importKeysBtn')?.addEventListener('click', () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        
        input.onchange = async (e) => {
            try {
                const file = e.target.files[0];
                const text = await file.text();
                const keyData = JSON.parse(text);
                
                if (!keyData.publicKey || !keyData.privateKey) {
                    throw new Error('å¯†é’¥æ–‡ä»¶æ ¼å¼é”™è¯¯');
                }
                
                const settings = await simpleSyncManager.getSyncSettings();
                settings.publicKey = keyData.publicKey;
                settings.privateKey = keyData.privateKey;
                await simpleSyncManager.saveSyncSettings(settings);
                
                await simpleSyncManager.cryptoManager.importKeys(
                    keyData.publicKey, 
                    keyData.privateKey
                );
                
                showNotification('å¯†é’¥å¯¼å…¥æˆåŠŸ', 'success');
                updateKeyInfo();
                
            } catch (error) {
                showNotification('å¯†é’¥å¯¼å…¥å¤±è´¥: ' + error.message, 'error');
            }
        };
        
        input.click();
    });
});

// æ›´æ–°å¯†é’¥ä¿¡æ¯æ˜¾ç¤º
async function updateKeyInfo() {
    const settings = await simpleSyncManager.getSyncSettings();
    const keyInfo = document.getElementById('keyInfo');
    
    if (settings.publicKey) {
        const fingerprint = await calculateKeyFingerprint(settings.publicKey);
        document.getElementById('keyFingerprint').textContent = fingerprint;
        keyInfo.style.display = 'block';
    } else {
        keyInfo.style.display = 'none';
    }
}

// è®¡ç®—å¯†é’¥æŒ‡çº¹
async function calculateKeyFingerprint(publicKeyPem) {
    const encoder = new TextEncoder();
    const keyBuffer = encoder.encode(publicKeyPem);
    const hashBuffer = await crypto.subtle.digest('SHA-256', keyBuffer);
    
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const fingerprint = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    
    return fingerprint.substring(0, 16).toUpperCase(); // æ˜¾ç¤ºå‰16ä½
}
```

## ğŸš€ éƒ¨ç½²å»ºè®®

### 1. æç®€æœåŠ¡ç«¯éƒ¨ç½²
```dockerfile
# Dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install --production

COPY . .

EXPOSE 3000

CMD ["node", "server.js"]
```

### 2. æœåŠ¡ç«¯é…ç½®
```javascript
// server.js - æç®€ç‰ˆæœ¬
const express = require('express');
const cors = require('cors');
const { Sequelize, DataTypes } = require('sequelize');

const app = express();
const PORT = process.env.PORT || 3000;

// ä¸­é—´ä»¶
app.use(cors());
app.use(express.json({ limit: '10mb' }));

// æ•°æ®åº“è¿æ¥ï¼ˆSQLiteï¼‰
const sequelize = new Sequelize({
    dialect: 'sqlite',
    storage: process.env.DB_PATH || './sync.db',
    logging: false
});

// æ•°æ®æ¨¡å‹
const SyncData = sequelize.define('SyncData', {
    id: {
        type: DataTypes.UUID,
        defaultValue: DataTypes.UUIDV4,
        primaryKey: true
    },
    domainGroup: {
        type: DataTypes.STRING,
        unique: true,
        allowNull: false
    },
    encryptedData: {
        type: DataTypes.TEXT,
        allowNull: false
    },
    dataHash: {
        type: DataTypes.STRING,
        allowNull: false
    },
    lastModified: {
        type: DataTypes.DATE,
        allowNull: false
    }
});

// APIè·¯ç”±
// ... (å‰é¢çš„APIä»£ç ) ...

// å¯åŠ¨æœåŠ¡å™¨
async function start() {
    await sequelize.sync();
    app.listen(PORT, () => {
        console.log(`æç®€åŒæ­¥æœåŠ¡å™¨è¿è¡Œåœ¨ç«¯å£ ${PORT}`);
    });
}

start().catch(console.error);
```

è¿™ä¸ªæç®€æ–¹æ¡ˆç§»é™¤äº†æ‰€æœ‰å¤æ‚åŠŸèƒ½ï¼Œä¸“æ³¨äºæ ¸å¿ƒçš„æ—¶é—´æˆ³åŒæ­¥å’Œéå¯¹ç§°åŠ å¯†ï¼Œå®Œå…¨æ»¡è¶³ä¸ªäººä½¿ç”¨éœ€æ±‚ã€‚ 